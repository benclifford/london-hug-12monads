<html>


<head>
 <meta charset="utf-8"/>
<title>12 Monads of Christmas preview talk</title>

<link rel="stylesheet" href="highlight.js/styles/default.css">
<script src="highlight.js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link rel="stylesheet" href="Slidy2/styles/slidy.css" type="text/css" />
<script src="Slidy2/scripts/slidy.js" charset="utf-8" type="text/javascript"></script> 
</head>

<body>

<div class="slide">
<h1>12 Monads of Christmas</h1>
<h2>a preview</h2>
<ul>
<li>Ben Clifford</li>
<li>benc@hawaga.org.uk</li>
</div>

<div class="slide">
<li>I was thinking about doing a blog series post</li>
<li>"12 monads of christmas"</li>
<li>which is 12 blog posts about monads...</li>
<li>and this talk is a preview of that.</li>
<li>Each day is a monad (or more) and something I think
is interesting about/around that monad.</li>

</div>

<div class="slide">
<h1>Day 1: IO</h1>
<h2>our ugly friend</h2>

<pre><code class="basic">
10 INPUT A$
20 PRINT A$
</code>
</pre>
</div>

<div class="slide">
<h1>Day 1: IO</h1>
<h2>our ugly friend</h2>

<pre><code class="haskell">
main = do
  v <- getLine
  putStrLn v
</code>
</pre>
</div>


<div class="slide">
<h1>Day 1: IO</h1>
<h2>our ugly friend</h2>

<pre><code class="haskell">
main = snd (head l)

l = [(3, a >>= b), undefined, (8, void)]

a = getLine
b = fst (putStrLn, putStrLn)

</code>
</pre>
</div>

<div class="slide">
<h1>Day 1: IO</h1>
<h2>our ugly friend</h2>

<pre><code class="haskell">
main =  getLine >>= \v ->
        putStrLn v

</code></pre>
</div>

<div class="slide">
<h1>Day 1: IO</h1>
<h2>our ugly friend</h2>

<pre><code class="haskell">
main =  (getLine) >>= (\v ->
        putStrLn v)
</code></pre>
</div>

<div class="slide">
<h1>Day 1: IO</h1>
<h2>our ugly friend</h2>

<pre><code class="haskell">
main = first_thing >>= rest_of_program

first_thing = getLine
rest_of_program v = putStrLn v
</code></pre>
</div>

<div class="handout">
<pre>
most people write stuff in IO. it's the type of main,
for example.

do notation

easy to think you are telling "haskell" 'do' these things
in order, when you write a 'do' expression.

you aren't.

p :: IO ()
p = 
do
  v <- a
  b v

is "just an expression" or "just a value"


x = (p, undefined)
y = [x,x,x]
z = fst $ head y
just like we might do with an integer.

compare this to basic

10 INPUT A$
20 PRINT A$

which we can't really manipulate (other than SAVE and LOAD to/from disk.)

finally we can run that value that we've been playing with...
main = z

now lets think about the structure of p.

do notations again. desugars into:

p = a >>= \v -> b v
p = a >>= b

which is an application of >>= to two parameters:

>>= is "in charge" here, to make a new expression of type 'IO something'

we can think of do notation as:

do
  v <- a
  rest_of_program

like this:

a >>= \v -> rest_of_program

and in a monad that usually means something like
'do' the the LHS and feeding in the value from that, 'do' the rest of the program (RHS)

? could bracked out a multi-line do block to show who gets to be in charge?

"Haskell" doesn't decide what this means.
The implementation around the IO type (via >>=) gets to decide.


</pre>

</div>

<div class="slide">
<h1>Day 2: []</h1>
<h2>seeing the rest of a program run</h2>

<pre><code class="haskell">
l = [ x * y | x <- [1,2,3], y <- [10,100] ]
-- [10,100,20,200,30,300]
</code></pre>

</div>

<div class="slide">
<h1>Day 2: []</h1>
<h2>seeing the rest of a program run</h2>

<pre><code class="haskell">
l = do
  x <- [1,2,3]
  y <- [10,100]
  return (x * y)
</code></pre>
</div>

<div class="slide">
<h1>Day 2: []</h1>
<h2>seeing the rest of a program run</h2>

<pre><code class="haskell">
l = first_thing >>= rest_of_program
 where 
  first_thing = [1,2,3]
  rest_of_program v = do
    y <- [10,100]
    return (v * y)
</code></pre>
</div>


<div class="slide">
<h1>Day 2: []</h1>
<h2>seeing the rest of a program run</h2>

<pre><code class="haskell">
first_thing = [1,2,3]
rest_of_program v = do
  y <- [10,100]
  return (v * y)

fmap rest_of_program first_thing
-- [[10,100] , [20,200], [30,300]]

join (fmap rest_of_program first_thing)
-- [10,100,20,200,30,300]
</code></pre>
</div>

<div class="slide">
<h1>Day 2: []</h1>
<h2>seeing the rest of a program run</h2>

<pre><code class="haskell">
first_thing :: IO String
first_thing = getLine

rest_of_program :: String -> IO ()
rest_of_program v = putStrLn v

prog :: IO (IO ())
prog = fmap rest_of_program first_thing

continue :: IO ()
continue <- prog

-- hands on demo?

join (fmap rest_of_program first_thing)
hello
hello
</code></pre>
</div>



<div class="handout">
<pre>
here's something that looks completely different:

> [ x * y | x <- [1,2,3], y <- [10,100] ]
[10,100,20,200,30,300]

or not so different:

do
  x <- [1,2,3]
  y <- [10,100]
  return (x * y)

let's force that into previous form:
  do
    v <- a
    b v

-- the first thing to 'do'
a = [1,2,3] -- not an IO action any more... the thing to 'do' is a list (?!)

-- the rest of the program
b v = do
  y <- [10,100]
  return (v*y)


but theres a different way to describe monads, using fmap (from Functor) and

join :: m (m a) -> m a

Equivalent to the >>= way of doing things.

I find this easiest to visualise with lists:

start with list a:

a = [1,2,3]

and run the rest of the program, assuming we've chosen each element in turn in
the list:


> fmap b a
[[10,100] , [20,200], [30,300]] :: [[Int]]

Nothing monadic yet - we've only used Functor.

We've got a list that contains what the rest
of the program would have done if we'd made
particular choices when we "did" the first
step of the program.

How do we get from 

[[10,100] , [20,200], [30,300]]
to

[10,100,20,200,30,300]
?

In [], that's concat. Or more generally,
that is what 'join' is.

So let's look at what that looks like for
IO:

do
  v <- getLine
  putStr v

==
getLine :: IO String
putStr :: String -> IO ()
fmap putStr getLine :: IO (IO ())

it's an IO action that when we run it,
will: read a line, and then return an
IO action that is the rest of the program,
passed that line:

Prelude> a <- fmap putStrLn getLine
> hello -- type this in
Prelude> :t a
a :: IO ()

and now we have "the rest of the program", captured
in a variable 'a',
that we can run:

Prelude> a
hello -- output

and run several times if we like:

Prelude> a
hello
Prelude> a
hello
Prelude> a
hello


</pre>
</div>

<div class="slide">
<h1>Day 3: Maybe</h1>
<h2>Mini-lists. Or mini-exceptions.</h2>

<pre>
[]   <====>   Nothing
[v]  <====>   Just v
</pre>

</div>

<div class="slide">

<p>Natural transformations:</p>
<pre><code class="haskell">
(Functor f, Functor g) => f a -> g a

maybeToList :: Maybe a -> [a]
listToMaybe :: [a] -> Maybe a -- | aka safe head
</code></pre>

</div>

<div class="slide">

<p>Checking natural transformation laws:</p>
<pre><code class="haskell">
nt :: (Functor f, Functor g) => f a -> g a

maybeToList :: Maybe a -> [a]
listToMaybe :: [a] -> Maybe a

func :: Integer -> Integer -- an arbitrary function
func = abs

quickCheck (\l -> ((fmap func) . listToMaybe) l == (listToMaybe . (fmap func)) l)
+++ OK, passed 100 tests.

quickCheck (\m -> ((fmap func) . maybeToList) m == (maybeToList . (fmap func)) m)
</code></pre>

</div>

<div class="slide">
<p>Monad morphism</p>

<p>Natural transformation + laws on monad instance:</p>

<pre><code class="haskell">
morph :: (Monad m, Monad n) => m a -> n a

maybeToList :: Maybe a -> [a]
listToMaybe :: [a] -> Maybe a
</code></pre>
<p>rule 1</p>
<pre><code class="haskell">
morph (return x) = return x

*Main Lib Test.QuickCheck Data.Maybe> quickCheck (\(x :: Integer) -> listToMaybe (return x) == return x)
+++ OK, passed 100 tests.
*Main Lib Test.QuickCheck Data.Maybe> quickCheck (\(x :: Integer) -> maybeToList (return x) == return x)
+++ OK, passed 100 tests.
</code></pre>
</div>

<div class="slide">
<p>Monad morphism</p>

<p>Natural transformation + laws on monad instance:</p>

<pre><code class="haskell">
morph :: (Monad m, Monad n) => m a -> n a

maybeToList :: Maybe a -> [a]
listToMaybe :: [a] -> Maybe a
</code></pre>
<p>rule 2</p>
<pre><code class="haskell">
morph $ do v <- a
           b v
     == 
do
  v <- morph a
  morph (b v)

checkMorph morph b = quickCheck $ \a ->
    (morph (do v <- a ; b v)) 
 == (do v <- morph a ; morph (b v))

-- use 'if' so that we're monadic, not just Functor
*Main Lib Test.QuickCheck Data.Maybe> checkMorph maybeToList (\(v :: Integer) -> if v >= 5 then Just v else Nothing)
+++ OK, passed 100 tests.

*Main Lib Test.QuickCheck Data.Maybe> checkMorph listToMaybe (\(v :: Integer) -> if v >= 5 then [v] else [])
*** Failed! Falsifiable (after 7 tests and 4 shrinks):    
[0,5]
</code></pre>
</div>

<div class="slide">
<p>only take one path - no non-determinism.</p>

<p>but can abandon that path at any time with Nothing.
don't backtrack. we've given up entirely.</p>

<p>...like exceptions</p>
<p>but "mini" exceptions because we don't return any "why"
information</p>

</div>

<div class="handout">
<pre>
see Maybe as a limited form of list:
it can be zero or one elements:

[]  <---> Nothing
[v] <---> Just v

this doesn't lose information:
maybeToList :: Maybe a -> [a]

but this does lose information:
listToMaybe :: [a] -> Maybe a

listToMaybe is aka safe head
 - it loses the tail of the list.

bit of category theory:
fmap commutes with maybeToList:

l :: [a]
f :: a -> b
fmap f (maybeToList l) = maybeToList (fmap f l)
 :: Maybe b

DRAW A NICE COMMUTING DIAGRAM HERE.
Mention Natural Transformation between Functors.

I think both maybeToList and listToMaybe are
natural transformations...

natural transformation is "fmap" works the same
whether you do it before/after to natural transformation


but what about if we treat it as a monad?
we don't get the same results out...

list explores all options of all options (list of list)
maybe only explores one option, and one option of that.


and that way, it's like mini-exceptions:
we can either return one thing at each stage, or we can "fail"
... and the monad fail instance is Nothing
    in Maybe:

fail _ = Nothing

-- we lose any exception information which is why I 
call them "mini-exceptions"

maybe it's interesting here to talk about monadplus
  left-distribution vs left-catch (rival laws)
see - https://wiki.haskell.org/MonadPlus

how does this work with lists? how does this work
with exceptions?

so how does it work with Maybe?

-- refer to monad morphism: natural transformation that
-- obeys additional rules - see top of:

https://hackage.haskell.org/package/mmorph-1.0.9/docs/Control-Monad-Morph.html#g:5

 i) return works in an "obvious" way

 ii) morph $ do x <- m  =  do x <- morph m
           f x           morph (f x)


can we make monad morphisms [] -> Maybe and Maybe -> []

I think (i) holds for both, but (ii) only holds for
taking Maybe -> [] - because [] -> Maybe we prune off
search paths, which may affect the head element of our
final result - the LHS might produce a result, but the
RHS would prune, and then search.

</pre>

</div>

<div class="slide">
<h1>Day 4: Reader, Writer, State</h1>
<h2>wiring together functions</h2>
<p>vs interacting with the world, or containers</p>
<p>Not going to say much, but here's a law for
reader monads:</p>
<pre>m >> n = n</pre>
<p>If we read a thing and then forget it, we might as
well have not done it in the first place.</p>
<p>(not for ReaderT)</p>

</div>

<div class="handout">
<pre>
[] and Maybe are "data structure" monad

IO is an Interacting-with-the-world monad

reader,writer,state are familair

these are "wiring function inputs/outputs together"
monads...

state threads a state thread as an extra parameter
to each function

reader threads an environment in to each function
without letting them modify it

writer takes some output from each function and
somehow combines all those outputs (eg as a Monoid)

is there much more to say?


For Reader monad:

  m >> n = n

If we do a thing, then discard the result,
it's the same as if we never did that first thing.
-- we can't observe "reading" happening.

This isn't the same for ReaderT, though because the
underlying monad might do something observable.

</pre>
</div>

<div class="slide">
<h1>Day 5: Set</h2>
<h2>these are harder than you’d first expect</h2>
<p>1. why you can't make a set monad</p>
<p>2. how you can make a set monad</p>
</div>

<div class="slide">
<h1>Day 5: Set</h2>
<p>A Set functor, with fake notation:</p>

<pre>
s = {-1,-3,3,7} :: Set Integer

fmap abs s = {1,3,7}
</pre>

<pre>instance Eq Integer
instance Ord Integer</pre>
</div>

<div class="slide">
<h1>Day 5: Set</h2>
<p>... but evil programmer can pick any type
to fmap with:</p>
<pre>
s = {-1,-3,3,7} :: Set Integer

fmap (const id) s = {id} :: Set (String -> String)
</pre>

<pre>instance Eq (String -> String) -- !!!
instance Ord (String -> String)</pre>
<p>Can't enforce <code>Eq</code> / <code>Ord</code>
for <code>fmap</code> / <code>>>=</code> / <code>join</code>
</p>
</div>

<div class="slide">
<h1>Day 5: Set</h2>
<p>Can't enforce <code>Eq</code> / <code>Ord</code>
for <code>fmap</code> / <code>>>=</code> / <code>join</code>
</p>

<p>... maybe we can put those constraints somewhere else?</p>
</div>

<div class="slide">
<pre><code class="haskell">import qualified Data.Set as S
data Set a where
  Prim   :: (Ord a) => S.Set a -> Set a
  Return :: a -> Set a
  Bind   :: Set a -> (a -> Set b) -> Set b
</code></pre>

<p>A sequence of "actions" bound together, that
we will evaluate later. Like creating an IO () value
and then evaluating it as <code>main</code>.</p>
<pre><code class="haskell">run :: (Ord a) => Set a -> S.Set a  -- can only run *some* sets
run (Prim s) = s
run (Return v) = S.singleton v
-- with a singleton, we don't need constraints to make one step:
run (Bind (Return v) f) = run (f v)
-- and with a Prim, we know that we have the constraints needed:
run (Bind (Prim s) f) = S.foldl' S.union S.empty (S.map (run . f) s)
</code></pre>
<p>Only feed in "interesting" sets if we have Ord,
and can only ask for the result if we have an Ord.
</p>
<p>Can't: <code>run (return id)</code></p>
</div>

<div class="handout">
<pre>
this is probably the first unfamiliar monad.

i was going to write that you can't do this, and explain
why.. but then I found someone had made an implementation.

so first why you can't do this. and then why you can.

1. Why can't you make a set monad?

superficially a set seems quite like a list.
it's a container of some values .

the difference is just that a list is sequenced and
can have duplicates. a set is unordered and cannot
contain duplicates.

how does that affect things?

the constructor for list is sort of:

data List a = Cons a (List a) | Nil
- an algebraic data type.

set doesn't work that way - you can't
make a definition like the above for
a set.

Data.Set instead has smart constructors - 
you can construct sets with things like
"singleton" and "empty" and combine them
with "union" and "intersection" which
are trusted (outside of the type system)
to do the right thing.

We can always make a single value into a
set, no matter what its' type:

singleton :: a -> Set a

but if we want to combine sets:

union :: Ord a => Set a -> Set a -> Set a 

we need some additional properties on 'a'
to be able to make sure we don't get
duplicates.

We don't have that for arbitary sets!

So we can't write, for example, fmap:

theoretically:
s = {1,2,3}
fmap (const k) s = {k}

but we can't compare k == k for
arbitrary types T, k :: T

so we can't build fmap. and we can't
build join (which would take the union
to give:
(Set (Set T)) -> Set T

a specific example is  T = Int -> String.
because functions are not comparable:

So we can't do fmap. we can't do join.
so we can't have Monad.

1b
concrete examples:

:t singleton (5 :: Integer) 
singleton (5 :: Integer) :: Set Integer

*Main Lib Data.Set> let a = singleton (5 :: Integer) 
*Main Lib Data.Set> let b = singleton (7 :: Integer) 

*Main Lib Data.Set> a `union` b
fromList [5,7]

*Main Lib Data.Set> a `union` a
fromList [5]

some kind of "Eq" testing going on there ^

*Main Lib Data.Set> fmap abs [-5,-3,1,3,7]
[5,3,1,3,7]

What should fmap be on set?

fmap abs { -5, -3 , 1, 3, 7 } => { 5,3,1,7 }

so someting like this on list:

*Main Lib Data.Set Data.List> nub $ fmap abs [-5,-3,1,3,7]
[5,3,1,7]

but:

*Main Lib Data.Set Data.List> nub [abs :: Integer -> Integer]
    • No instance for (Eq (Integer -> Integer))

so we can't always implement it that way.

see that the "spine" of the structure has changed - we fed in 5
elements and got out 4. That's to do with a Set not being a
normal algebraic data type, from a functor perspective.

2. How you can make a set monad.

See the <a href="https://hackage.haskell.org/package/set-monad">set-monad</a> package.

import Data.Set.Monad
:t fmap abs (fromList [-5,-3,1,3,7 :: Integer]) fmap abs (fromList [-5,-3,1,3,7 :: Integer]) :: Set Integer
*Main Lib Data.Set.Monad> fmap abs (fromList [-5,-3,1,3,7])
fromList [1,3,5,7]

 do { a <- fromList [0,1,2] ; b <- fromList [0,1,2] ; return $ a + b} :: Set Integer
fromList [0,1,2,3,4]

cf
*Main Lib Data.Set.Monad> do { a <- [0,1,2] ; b <- [0,1,2] ; return $ a + b} :: [Integer]
[0,1,2,1,2,3,2,3,4]

*Main Lib Data.Set.Monad> let f = id :: Integer -> Integer
*Main Lib Data.Set.Monad> let g = abs :: Integer -> Integer
*Main Lib Data.Set.Monad> :t [f,g]
[f,g] :: [Integer -> Integer]

*Main Lib Data.Set.Monad> [b a | a <- [1,2,3], b <- [f,g]]
[1,1,2,2,3,3]
or this
*Main Lib Data.Set.Monad> do { a <- [-3,1,3 :: Integer] ; b <- [f,g] ; return (b a) }
[-3,3,1,1,3,3]

*Main Lib Data.Set.Monad> :set -XMonadComprehensions

however we can't do things that don't make sense:

*Main Lib Data.Set.Monad> let funcs = fromList [f,g]

<interactive>:26:13: error:
    • No instance for (Ord (Integer -> Integer))

*Main Lib Data.Set.Monad> let f1 = return f :: Set (Integer -> Integer)
*Main Lib Data.Set.Monad> :t f1
f1 :: Set (Integer -> Integer)

f1 is a set of functions (but only one element)

*Main Lib Data.Set.Monad> do { a <- fromList [-3,1,3 ::Integer]; b <- f1 ; return $ b a }
fromList [-3,1,3]

but magically restricted in what we can do with that set:

*Main Lib Data.Set.Monad> f1 `union` f1

<interactive>:43:1: error:
    • No instance for (Ord (Integer -> Integer))
        arising from a use of ‘union’


We've moved constraints around so instead of being on the
data type of Set, they're on the various operations that need
them.

So you can always make a one element set out of a single
value, no constraints needed. (return f)

and you can use that in a monadic context (b <- f1)
 - we're going to iterate over all the values but theres only one.

but not intersection/union

The constructors for Data.Monad.Set distinguish between these
two cases:

<a href="https://hackage.haskell.org/package/set-monad-0.2.0.0/docs/src/Data-Set-Monad.html#Set">from the source code</a>:

data Set a where
  Prim   :: (Ord a) => S.Set a -> Set a
  Return :: a -> Set a

you can have a regular set (with Ord constraint) or one of these
special case singleton sets (without).

(This is a free monad, and we'll come to those later)

using "free monad" in the same way that imaginary numbers
are constructed, sort of - imagine if we *could* construct
a set this way... imagine if we could construct sqrt(-1)...
but then it doesn't always make sense - we can only evaluate
it in certain contexts.


(btw i discovered there is a thing,
<a href="https://blog.acolyer.org/2014/11/06/the-boom-hierarchy/">The Boom Hierarchy</a>
and a term "ringad" for collection-like monads)
</pre>
</div>

<div class="slide">
<h1>Day 6: Conduit</h1>
<h2>piping together computations</h2>

<p>Co-routines</p>
<p>Better resource management - eg constant space</p>
<p>Pass values down a pipe</p>
<p><pre>source .| conduit .| conduit .| sink</pre></p>

</div>

<div class="slide">
<pre>
source = do
  liftIO $ putStrLn "Starting stage 1 in source"
  yield 1
  yield 2
  liftIO $ putStrLn "Starting stage 2 in source"
  sourceList [100..200]

sink :: ConduitM Integer Void IO
sink :: Sink Integer IO ()
sink = do
  liftIO $ putStrLn "Starting sink"
  v <- await
  liftIO $ putStrLn $ "sink got: " ++ (show v)
</pre>

<pre>
> runConduit (source .| sink)
Starting sink
Starting stage 1 in source
sink got: Just 1
</pre>

</div>

<div class="slide">
<pre>
somefilter :: ConduitM Integer Integer IO ()
somefilter = do
  liftIO $ putStrLn "filter: awaiting"
  v <- await
  case v of
    Nothing -> do
      liftIO $ putStrLn "filter: reached end of stream"
    Just v | v > 102 -> do
      liftIO $ putStrLn "filter: passing on value"
      yield v
      somefilter
    Just v -> do
      liftIO $ putStrLn $ "filter: skipping value: " ++ (show v)
      somefilter
</pre>

<pre>
> runConduit (source .| somefilter .| sink)
Starting sink
filter: awaiting
Starting stage 1 in source
filter: skipping value: 1
filter: awaiting
filter: skipping value: 2
filter: awaiting
Starting stage 2 in source
filter: skipping value: 100
filter: awaiting
filter: skipping value: 101
filter: awaiting
filter: skipping value: 102
filter: awaiting
filter: passing on value
sink got: Just 103
</pre>
</div>

<div class="handout">
<pre>


<pre><code class="haskell">data ConduitM input output m result</code></pre>
<p>Source:</p>
<pre><code class="haskell">ConduitM () output m ()</code></pre>
<p>Sink:</p>
<pre><code class="haskell">ConduitM input Void m result</code></pre>
</code></pre>



Conduits let you pipe together streams of data with more
control over resource usage than doing lazy IO.

We've got sources (which generate data for piping),
sinks (which take data for piping) and more general
conduits which sink some data and source some data.

I'm going to do all this in Conduit over IO - Conduit itself
is a monad transformer.

*Main Lib Data.Conduit> generator = yield 3

*Main Lib Data.Conduit Control.Monad.IO.Class> printer = do { v <- await; liftIO $ putStrLn $ "We got: " ++ (show v) }

*Main Lib Data.Conduit Control.Monad.IO.Class> runConduit (generator .| printer)
We got: Just 3

or we can do:

*Main Lib Data.Conduit Control.Monad.IO.Class> printer3 = printer >> printer >> printer
*Main Lib Data.Conduit Control.Monad.IO.Class> runConduit (generator .| printer3)
We got: Just 3
We got: Nothing
We got: Nothing

.| aka `fuse`

draw nice diagram - fusing horizontally

monadic composition vertically - three x printer, for example.

So how is this useful?

* better resource control. can pass values round one at a time,
rather than building a list of all values and hoping that it
is dealt with suitably lazily.

* interleave actions in underlying monad with conduit behaviour
 - hard to do with lists.

introduce conduitm and some specialisations:
   source (no input)
   sink (no output)
   conduit (no return value)


example:
 source can do dsomething complicated - http request for paged
   data, which involves getting a page, yielding all the records
   on that page, then getting next page, etc.

 sink can "await" next record, without needing to co-ordinate
  any of this

 we get composability
</pre>
</div>

<div class="slide">
<h1>Day 7: Haxl</h1>
<h2>The Reader monad, when reads are expensive</h2>

<p>Reader:
<pre>
  do
    v <- ask
    v' = get_field v
</pre>
<p>But <code>ask</code> might be expensive...</p>
<p>Big - send queries to data store rather than
   processing locally</p>
<p>Slow</p>
<p>Starts to sound like IO?</p>
<p>Claim: still Reader-like. <code>m >> n == n</code></p>

</div>

<div class="slide">
<p>Queries have no effect on the environment: <code>m >> n == n</code></p>

<p>If we know several queries, can run:
<ul>
 <li>In any order</li>
 <li>In parallel</li>
</ul>
</p>

<p>But monad forces sequencing even if not needed...</p>
<pre>
m >>= \_ -> n
</pre>
<p>Must run query <code>m</code> in order to get a value <code>_</code>
to ignore.
<pre>
m >>= \x -> n >>= \y -> return (x,y)
</pre>
<p>Values might be needed, but not until later.</p>
</div>

<div class="slide"><h1>Applicatives</h1>
<p><code>Applicative</code> to the rescue</p>

<p> <code>>>=</code> but weaker</p>
<p>Actions never see earlier values</p>

<pre>&lt;*> :: m (a -> b) -> m a -> m b
lhs &lt;*> rhs = do
  f <- lhs
  v <- rhs
  return (f v)
</pre>

<p>or</p>

<pre>** :: m a -> m b -> m (a,b)
lhs ** rhs = do
  a <- lhs
  b <- rhs
  return (a,b)
</pre>

<p>ApplicativeDo notation - desugars into <*> where possible and >>= where not</p>

</div>

<div class="handout">
<pre>

it's a monad. but the interesting stuff happens when
you use it as an applicative functor.

applicative functor is somewhere between 

* a functor (which gives you `fmap`)

* and a monad, which gives you:
 join, >>= (bind), return

Applicative has fmap, and <*> "apply"

  (<*>) :: f (a -> b) -> f a -> f b

Like monad, there's another formulation:

  (**) :: f a -> f b -> f (a,b)

We do "do" two things in an applicative f and
then somehow combine them.

But we are restricted in how the LHS can inflence
the RHS - the RHS can't see the value that's come
out of the LHS, but the values get stuck together
at the end (using function composition in the
first case or (,) in the second case.

so back to haxl.

When you're a client of haxl, you can execute a
query against some data source.

That query might take a long time because of
eg network/database latency.

monadic style:

report n a = putStrLn $ "Your name is " ++ name ++ " and your age is " ++ show age

do
  name <- getName - 500ms
  age <- getAge person -- 500ms
  report name age

total run time 1 second.

But we could have run getName and getAge in parallel - we didn't
need to know the value of "name" in order to run
getAge person.

but the monadic interface means we have to do that - we have
to pass on the value of "name" even though on visual
inspection it doesn't matter until much later.

but this is what applicatives provide!

rather than

  getname >>= \name -> getAge >>= \age -> report name age

we could instead write something like:

 do
  (name,age) <- (,) <$> getName <*> getAge
  report name age

so we've got a monadic step still, but one of the
actions is both queries at the same time.

In ghc 8, there's applicative-do, which means that
do notation gets desugared into applicative where
possible - the results should evaluate to be the
same (as long as the applicative and monad instances
work together properly)

There are also things that can't be monads, that can
be applicatives.

For example, ZipList.


</pre>
</div>

<div class="slide">
<h1>Day 8: LogicT</h1>
<h2>more interesting stuff with evaluating lists</h2>
<blockquote>A library for adding backtracking computations
to any Haskell monad</blockquote>
<p><a href="http://okmij.org/ftp/Computation/LogicT.pdf">LogicT.pdf</a></p>
</div>

<div class="slide">
<h2>Unfair disjunction</h2>

<pre class="haskell">
positives = [1..]
negatives = map (* (-1)) [1..]
the_numbers = positives ++ [0] ++ negatives
</pre>

<p>"Search" for a number bigger than 100:</p>
<pre class="haskell">
a_solution = head $ do
  n <- the_numbers
  guard (n > 100)
  return n
</pre>

<pre>
print a_solution
101
</pre>
</div>

<div class="slide">

<pre class="haskell">
positives = [1..]
negatives = map (* (-1)) [1..]
the_numbers = positives ++ [0] ++ negatives
</pre>

<p>"Search" for a number smaller than 0:</p>
<p>For example, <code>-1</code></p>
<pre class="haskell">
a_solution = head $ do
  n <- the_numbers
  guard (n < 0)
  return n
</pre>

<pre>
print a_solution
... hangs ...
</pre>

</div>

<div class="slide">
<p><code>++</code> is "unfair": LHS is treated differently to RHS</p>

<pre class="haskell">import Control.Monad.Logic
the_numbers = positives `interleave` [0] `interleave` negatives

a_solution = head $ do
  n <- the_numbers
  guard (n < 0)
  return n

print a_solution
-1

print (take 10 the_numbers)
[1,-1,0,-2,2,-3,3,-4,4,-5]
</pre>
</div>

<div class="slide">
<p><code>++</code> for <code>ListT m</code></p>

<pre>
a `mplus` b = do
  lhs <- a
  rhs <- b
  return (lhs ++ rhs)
</pre>

<p>What does it mean to interleave rather than ++?</p>
<p>Interleave at the end is too late</p>
<p>Run lhs a little bit, then run rhs a little bit, then
run lhs a little bit more.</p>
<p>Ramble about co-routines  - compare to conduit.</p>
</div>



<div class="handout">
<p>
"A library for adding backtracking computations to any
Haskell monad" - <a href="http://okmij.org/ftp/Computation/LogicT.pdf">LogicT.pdf</a>

</p>

<pre>
Let's do a simple search:
let's try to find a number bigger than 100.

assemble all the integers: the postives, zero and
the negatives, using (++), into a single list.

the_numbers = [1..] ++ [0] ++ map (* (-1)) [1..]

We'll take the first solution returned by this
do-block:

head $ do
  n <- the_numbers
  guard (n > 100)
  return n

101

Now let's find a number less than 10:

head $ do
  n <- the_numbers
  guard (n < 10)
  return n

1

And now let's fine a number less than 0:

Straightforward, right?

head $ do
  n <- the_numbers
  guard (n < 0)
  return n

[... infinite wait ... infinite cpu ...]

What's gone wrong?

the_numbers = [1..] ++ [0] ++ map (* (-1)) [1..]

before we consider 0 and the negatives, we need to consider all
of the positives. all of them. only when we've exhausted [1..] will
we move onto evaluating the RHS terms. which is never.

whoops.


import Control.Monad.Logic

*Main Lib Control.Monad.Logic> return 5 :: [Integer]
[5]

*Main Lib Control.Monad.Logic> return 5 :: Logic Integer

<interactive>:8:1: error:
    • No instance for (Show (Logic Integer))

but we can "observe" one result:

> observe (return 5 :: Logic Integer)
5

observe acts like "head"

(return 5 :: [Integer]) `mplus` return 6
[5,6]

observe $ (return 5 :: Logic Integer) `mplus` return 6
5

observeAll $ (return 5 :: Logic Integer) `mplus` return 6
[5,6]

So this is behaving quite like a list.

Let's try out our original problem using Logic:

fromList (x:xs) = return x `mplus` fromList xs ; fromList [] = mzero

zero = return 0
positives = fromList [1..]
negatives = fmap (* (-1)) positives
the_numbers = positives `mplus` zero `mplus` negatives

This hangs...
but we have a new primitive available, interleave, which is
a bit like monadplus, but "fairer":

*Main Lib Control.Monad.Logic> the_numbers = positives `interleave` zero `interleave` negatives
*Main Lib Control.Monad.Logic> observe $ do { n <- the_numbers ; guard (n <= 0) ; return n }
-1

*Main Lib Control.Monad.Logic> take 10 $ observeAll the_numbers
[1,-1,0,-2,2,-3,3,-4,4,-5]

interleave could have been implemented as a different ++ style
operator on lists, so why do we need LogicT?


LogicT provides other stuff...
it's a transformer over arbitrary monads. (I think it's hard to do backtracking fairly over arbitrary monads?)

What does it mean to `mplus` two IO actions, for example?

Can phrase in terms of (pure) lists quite easily.

 * ifte - soft cut:

  ifte t th el  - if t succeeds at least once,  t >>= th
                  if t never succeeds, el
  (so el is our "else" / "error handling" / explain why we
    failed here...)

 * once - pruning
   once a   - selects a single solution from a - it never backtracks
     to select any others.
    - for example, when looking for a counter example, there might
       be many counter examples, but we really only care about finding
       any one of them, rather than enumerating all of them.
    but we can do this within our backtracking computation.
    (rather than external to it, which is where head/observe live

these operators are able to do things that list doesn't: they
can observe what's happening to the non-deterministic 
evaluation in a way that something living in [] cannot.
  - observations on the computation as a whole live outside like
  head.

</pre>

</div>

<div class="slide">
<h1>Day 9: Free</h1>
<h2>Free monads</h2>

<p>Already saw these a bit with set...</p>
<p>Describe how to build a set, rather than actually building it...
<pre><code class="haskell">data Set a where
  Prim   :: (Ord a) => S.Set a -> Set a
  Return :: a -> Set a
  Bind   :: Set a -> (a -> Set b) -> Set b
</code></pre>
<p>.. and then interpret (<code>run</code>) that description:</p>
<pre><code class="haskell">run :: (Ord a) => Set a -> S.Set a</code></pre>
<p>Standard monad stuff and then some special stuff.</p>
<p>Make a monad out of any "special stuff". Up to the interpreter
to understand what to do with it.
</p>
<p>Many different interpreters for same free monad</p>
</div>

<div class="slide">
<p><code>Control.Monad.Free</code>: "special stuff" 
a <code>Functor</code> (<code>fmap</code>)</p>

<p><monad>Freer</em> monad doesn't even need that - move
fmap into the interpreter too.</p>
</div>

<div class="slide">
<pre><code class="haskell">
data FFree f a where
  Pure :: a -> FFree f  a
  Impure :: f x -> (x -> FFree f a) -> FFree f a

data SetFF a where
    Prim :: (Ord a) => S.Set a -> SetFF a

type Set a = Free SetFF a
</code>
</pre>
</div>


<div class="handout">
back reference to Set (maybe set should be right before this and
smooth transition in?) - capture the structure of the computation
in a data structure - show full data type for Data.Monad.Set
and separately have a "run" function that runs that particular
set. and it's at the run stage that we get our type errors, not
at our construction stage. potentially we could have a different
run function!

Free monad usually based around an existing Functor, but you
can move the Functor implementation into an interpreter too,
using a free functor.

other free structure: Free monoid - is a list! can "interpret"
a list into anything that you can write a monoid instance for
</div>

<div class="slide">
<h1>Day 10:  Eff</h1>
<h2>modular interpreters and extensible effects</h2>
<p>Union data type and injections:</p>
<pre><code class="haskell">type X = Either String Integer
Left :: String -> X
Right :: Integer -> X
</code>
</pre>

</div>

<div class="handout">
<pre>
* alternative to monad transformers
* compose interpreters
* difference in what can be expressed
* not so strictly layered
* I've used two implementations, based on different free monad
implementations.
</pre>
</div>

<div class="slide">
<h1>Day 11: Key</h1>
<h2>safe dynamic typing</h2>
</div>

<div class="handout">


http://www.cse.chalmers.se/~atze/papers/keymonad.pdf
also see:
https://www.seas.upenn.edu/~sweirich/papers/wadlerfest2016.pdf
for similar stuff

</div>

<div class="slide">
<h1>Day 12: Cont</h1>
<h2>continuations</h2>
</div>

<div class="handout">
<pre>
Continuations represent the rest of the
program to be run.

But wait, we've seen this somewhere before...

Right back at the start.

A monad gives us expressions that look like this:

 action >>= rest_of_program

we can do an action, and then we pass in the rest
of the program to be run, and the monad implementation
makes the rest of the program happen.
(perhaps several times or never, like in a list - it
doesn't matter - it's available to the monad
implementation to do what it cares to)

Cont makes "the rest of the program" available inside
your monadic code, with a single action:


callCC :: ((a -> Cont r b) -> Cont r a) -> Cont r a

Cont r a is a computation that will at the very end of the
program return a value of type r, but this particular piece
of computation will return a value of type a.

Run it with runCont (or runContT in this case)

callCC action  means "don't run the rest of the program.
Run action instead. (This isn't a function call - when
action exits, we don't return to where callCC was invoked).

BUT! action gets passed the rest of the program as a parameter.

and that parameter is itself a monadic action we can call which
will abandon whatever program is running and go back and
carry on as if we'd just returned from the callCC.

Sound confusing? It is. It's like the GOTO of functional programming...

We can do things like "early return" - like the return statement
of C/Java - but we can return from deep inside. so that bit
is quite like throwing an exception rather than returning.

or we could store the continuation in a table for use later on
-- to implement co-routines or a co-operative multitasking
scheduler. or for use as a callback: go stop what i'm doing now
and "return" (via the continuation) to carry on when you have
whatever the callback is for.

or look at funcD - we don't even have to run the rest of the
program. we can just ignore it and go run some arbitrary
code, and when that arbitrary code ends, that's the end of
runContT - we never get back to contMain.

very powerful. very confusing.

i've used it for a DNS diagnostic program which was non-deterministic
over DNS caches and servers 
- DNS caching looks weird so a regular list-style
non-determinism wasn't good enough.
</pre>

</div>

<div class="slide">
<p>-fin-</p>

<p><a href="https://www.meetup.com/London-Haskell/events/235629296/">meetup.com event</a></p>


</div>

</html>
