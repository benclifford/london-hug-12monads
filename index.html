<html>


<head>
 <meta charset="utf-8"/>
<title>12 Monads of Christmas preview talk</title>

<link rel="stylesheet" href="highlight.js/styles/default.css">
<script src="highlight.js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link rel="stylesheet" href="Slidy2/styles/slidy.css" type="text/css" />
<script src="Slidy2/scripts/slidy.js" charset="utf-8" type="text/javascript"></script> 
</head>

<body>

<div class="slide">
<h1>12 Monads of Christmas</h1>
<h2>a preview</h2>
<ul>
<li>Ben Clifford</li>
<li>benc@hawaga.org.uk</li>
</div>

<div class="slide">
<li>I was thinking about doing a blog series post</li>
<li>"12 monads of christmas"</li>
<li>which is 12 blog posts about monads...</li>
<li>and this talk is a preview of that.</li>
<li>Each day is a monad (or more) and something I think
is interesting about/around that monad.</li>

</div>

<div class="slide">
<h1>Day 1: IO</h1>
<h2>our ugly friend</h2>

<pre>
most people write stuff in IO. it's the type of main,
for example.

do notation

easy to think you are telling "haskell" 'do' these things
in order, when you write a 'do' expression.

you aren't.

p :: IO ()
p = 
do
  v <- a
  b v

is "just an expression" or "just a value"


x = (p, undefined)
y = [x,x,x]
z = fst $ head y
just like we might do with an integer.

compare this to basic

10 INPUT A$
20 PRINT A$

which we can't really manipulate (other than SAVE and LOAD to/from disk.)

finally we can run that value that we've been playing with...
main = z

now lets think about the structure of p.

do notations again. desugars into:

p = a >>= \v -> b v
p = a >>= b

which is an application of >>= to two parameters:

>>= is "in charge" here, to make a new expression of type 'IO something'

we can think of do notation as:

do
  v <- a
  rest_of_program

like this:

a >>= \v -> rest_of_program

and in a monad that usually means something like
'do' the the LHS and feeding in the value from that, 'do' the rest of the program (RHS)

? could bracked out a multi-line do block to show who gets to be in charge?

"Haskell" doesn't decide what this means.
The implementation around the IO type (via >>=) gets to decide.


</pre>

</div>

<div class="slide">
<h1>Day 2: []</h1>
<h2>seeing the rest of a program run</h2>

<pre>
here's something that looks completely different:

> [ x * y | x <- [1,2,3], y <- [10,100] ]
[10,100,20,200,30,300]

or not so different:

do
  x <- [1,2,3]
  y <- [10,100]
  return (x * y)

let's force that into previous form:
  do
    v <- a
    b v

-- the first thing to 'do'
a = [1,2,3] -- not an IO action any more... the thing to 'do' is a list (?!)

-- the rest of the program
b v = do
  y <- [10,100]
  return (x*y)


but theres a different way to describe monads, using fmap (from Functor) and

join :: m (m a) -> m a

Equivalent to the >>= way of doing things.

I find this easiest to visualise with lists:

start with list a:

a = [1,2,3]

and run the rest of the program, assuming we've chosen each element in turn in
the list:


> fmap b a
[[10,100] , [20,200], [30,300]] :: [[Int]]

Nothing monadic yet - we've only used Functor.

We've got a list that contains what the rest
of the program would have done if we'd made
particular choices when we "did" the first
step of the program.

How do we get from 

[[10,100] , [20,200], [30,300]]
to

[10,100,20,200,30,300]
?

In [], that's concat. Or more generally,
that is what 'join' is.

So let's look at what that looks like for
IO:

do
  v <- getLine
  putStr v

==
getLine :: IO String
putStr :: String -> IO ()
fmap putStr getLine :: IO (IO ())

it's an IO action that when we run it,
will: read a line, and then return an
IO action that is the rest of the program,
passed that line:

Prelude> a <- fmap putStrLn getLine
> hello -- type this in
Prelude> :t a
a :: IO ()

and now we have "the rest of the program", captured
in a variable 'a',
that we can run:

Prelude> a
hello -- output

and run several times if we like:

Prelude> a
hello
Prelude> a
hello
Prelude> a
hello


</pre>
</div>

<div class="slide">
<h1>Day 3: Maybe</h1>
<h2>Mini-lists. Or mini-exceptions.</h2>

<pre>
see Maybe as a limited form of list:
it can be zero or one elements:

[]  <---> Nothing
[v] <---> Just v

this doesn't lose information:
maybeToList :: Maybe a -> [a]

but this does lose information:
listToMaybe :: [a] -> Maybe a

listToMaybe is aka safe head
 - it loses the tail of the list.

bit of category theory:
fmap commutes with maybeToList:

l :: [a]
f :: a -> b
fmap f (maybeToList l) = maybeToList (fmap f l)
 :: Maybe b

DRAW A NICE COMMUTING DIAGRAM HERE.
Mention Natural Transformation between Functors.

but what about if we treat it as a monad?
we don't get the same results out...

list explores all options of all options (list of list)
maybe only explores one option, and one option of that.


and that way, it's like mini-exceptions:
we can either return one thing at each stage, or we can "fail"
... and the monad fail instance is Nothing
    in Maybe:

fail _ = Nothing

-- we lose any exception information which is why I 
call them "mini-exceptions"

maybe it's interesting here to talk about monadplus
  left-distribution vs left-catch (rival laws)
see - https://wiki.haskell.org/MonadPlus

how does this work with lists? how does this work
with exceptions?

so how does it work with Maybe?

</pre>

</div>

<div class="slide">
<h1>Day 4: Reader, Writer, State</h1>
<h2>wiring together functions</h2>

<pre>
[] and Maybe are "data structure" monad

IO is an Interacting-with-the-world monad

reader,writer,state are familair

these are "wiring function inputs/outputs together"
monads...

state threads a state thread as an extra parameter
to each function

reader threads an environment in to each function
without letting them modify it

writer takes some output from each function and
somehow combines all those outputs (eg as a Monoid)

is there much more to say?


For Reader monad:

  m >> n = n

If we do a thing, then discard the result,
it's the same as if we never did that first thing.
-- we can't observe "reading" happening.

This isn't the same for ReaderT, though because the
underlying monad might do something observable.

</pre>
</div>

<div class="slide">
<h1>Day 5: Set</h2>
<h2>these are harder than you’d first expect</h2>

<pre>
this is probably the first unfamiliar monad.

i was going to write that you can't do this, and explain
why.. but then I found someone had made an implementation.

so first why you can't do this. and then why you can.

1. Why can't you make a set monad?

superficially a set seems quite like a list.
it's a container of some values .

the difference is just that a list is sequenced and
can have duplicates. a set is unordered and cannot
contain duplicates.

how does that affect things?

the constructor for list is sort of:

data List a = Cons a (List a) | Nil
- an algebraic data type.

set doesn't work that way - you can't
make a definition like the above for
a set.

Data.Set instead has smart constructors - 
you can construct sets with things like
"singleton" and "empty" and combine them
with "union" and "intersection" which
are trusted (outside of the type system)
to do the right thing.

We can always make a single value into a
set, no matter what its' type:

singleton :: a -> Set a

but if we want to combine sets:

union :: Ord a => Set a -> Set a -> Set a 

we need some additional properties on 'a'
to be able to make sure we don't get
duplicates.

We don't have that for arbitary sets!

So we can't write, for example, fmap:

theoretically:
s = {1,2,3}
fmap (const k) s = {k}

but we can't compare k == k for
arbitrary types T, k :: T

so we can't build fmap. and we can't
build join (which would take the union
to give:
(Set (Set T)) -> Set T

a specific example is  T = Int -> String.
because functions are not comparable:

So we can't do fmap. we can't do join.
so we can't have Monad.

1b
concrete examples:

:t singleton (5 :: Integer) 
singleton (5 :: Integer) :: Set Integer

*Main Lib Data.Set> let a = singleton (5 :: Integer) 
*Main Lib Data.Set> let b = singleton (7 :: Integer) 

*Main Lib Data.Set> a `union` b
fromList [5,7]

*Main Lib Data.Set> a `union` a
fromList [5]

some kind of "Eq" testing going on there ^

*Main Lib Data.Set> fmap abs [-5,-3,1,3,7]
[5,3,1,3,7]

What should fmap be on set?

fmap abs { -5, -3 , 1, 3, 7 } => { 5,3,1,7 }

so someting like this on list:

*Main Lib Data.Set Data.List> nub $ fmap abs [-5,-3,1,3,7]
[5,3,1,7]

but:

*Main Lib Data.Set Data.List> nub [abs :: Integer -> Integer]
    • No instance for (Eq (Integer -> Integer))

so we can't always implement it that way.

see that the "spine" of the structure has changed - we fed in 5
elements and got out 4. That's to do with a Set not being a
normal algebraic data type, from a functor perspective.

2. How you can make a set monad.

See the <a href="https://hackage.haskell.org/package/set-monad">set-monad</a> package.

import Data.Set.Monad
:t fmap abs (fromList [-5,-3,1,3,7 :: Integer]) fmap abs (fromList [-5,-3,1,3,7 :: Integer]) :: Set Integer
*Main Lib Data.Set.Monad> fmap abs (fromList [-5,-3,1,3,7])
fromList [1,3,5,7]

 do { a <- fromList [0,1,2] ; b <- fromList [0,1,2] ; return $ a + b} :: Set Integer
fromList [0,1,2,3,4]

cf
*Main Lib Data.Set.Monad> do { a <- [0,1,2] ; b <- [0,1,2] ; return $ a + b} :: [Integer]
[0,1,2,1,2,3,2,3,4]

*Main Lib Data.Set.Monad> let f = id :: Integer -> Integer
*Main Lib Data.Set.Monad> let g = abs :: Integer -> Integer
*Main Lib Data.Set.Monad> :t [f,g]
[f,g] :: [Integer -> Integer]

*Main Lib Data.Set.Monad> [b a | a <- [1,2,3], b <- [f,g]]
[1,1,2,2,3,3]
or this
*Main Lib Data.Set.Monad> do { a <- [-3,1,3 :: Integer] ; b <- [f,g] ; return (b a) }
[-3,3,1,1,3,3]

*Main Lib Data.Set.Monad> :set -XMonadComprehensions

however we can't do things that don't make sense:

*Main Lib Data.Set.Monad> let funcs = fromList [f,g]

<interactive>:26:13: error:
    • No instance for (Ord (Integer -> Integer))

*Main Lib Data.Set.Monad> let f1 = return f :: Set (Integer -> Integer)
*Main Lib Data.Set.Monad> :t f1
f1 :: Set (Integer -> Integer)

f1 is a set of functions (but only one element)

*Main Lib Data.Set.Monad> do { a <- fromList [-3,1,3 ::Integer]; b <- f1 ; return $ b a }
fromList [-3,1,3]

but magically restricted in what we can do with that set:

*Main Lib Data.Set.Monad> f1 `union` f1

<interactive>:43:1: error:
    • No instance for (Ord (Integer -> Integer))
        arising from a use of ‘union’


We've moved constraints around so instead of being on the
data type of Set, they're on the various operations that need
them.

So you can always make a one element set out of a single
value, no constraints needed. (return f)

and you can use that in a monadic context (b <- f1)
 - we're going to iterate over all the values but theres only one.

but not intersection/union

The constructors for Data.Monad.Set distinguish between these
two cases:

<a href="https://hackage.haskell.org/package/set-monad-0.2.0.0/docs/src/Data-Set-Monad.html#Set">from the source code</a>:

data Set a where
  Prim   :: (Ord a) => S.Set a -> Set a
  Return :: a -> Set a

you can have a regular set (with Ord constraint) or one of these
special case singleton sets (without).

(This is a free monad, and we'll come to those later)

(btw i discovered there is a thing,
<a href="https://blog.acolyer.org/2014/11/06/the-boom-hierarchy/">The Boom Hierarchy</a>
and a term "ringad" for collection-like monads)
</pre>
</div>

<div class="slide">
<h1>Day 6: Conduit</h1>
<h2>piping together computations</h2>
<pre>
Conduits let you pipe together streams of data with more
control over resource usage than doing lazy IO.

We've got sources (which generate data for piping),
sinks (which take data for piping) and more general
conduits which sink some data and source some data.

I'm going to do all this in Conduit over IO - Conduit itself
is a monad transformer.

*Main Lib Data.Conduit> generator = yield 3

*Main Lib Data.Conduit Control.Monad.IO.Class> printer = do { v <- await; liftIO $ putStrLn $ "We got: " ++ (show v) }

*Main Lib Data.Conduit Control.Monad.IO.Class> runConduit (generator .| printer)
We got: Just 3

or we can do:

*Main Lib Data.Conduit Control.Monad.IO.Class> printer3 = printer >> printer >> printer
*Main Lib Data.Conduit Control.Monad.IO.Class> runConduit (generator .| printer3)
We got: Just 3
We got: Nothing
We got: Nothing

.| aka `fuse`

draw nice diagram - fusing horizontally

monadic composition vertically - three x printer, for example.

So how is this useful?

* better resource control. can pass values round one at a time,
rather than building a list of all values and hoping that it
is dealt with suitably lazily.

* interleave actions in underlying monad with conduit behaviour
 - hard to do with lists.

introduce conduitm and some specialisations:
   source (no input)
   sink (no output)
   conduit (no return value)


example:
 source can do dsomething complicated - http request for paged
   data, which involves getting a page, yielding all the records
   on that page, then getting next page, etc.

 sink can "await" next record, without needing to co-ordinate
  any of this

 we get composability
</pre>
</div>

<div class="slide">
<h1>Day 7: Haxl</h1>
<h2>The Reader monad, when reads are expensive</h2>

<pre>

it's a monad. but the interesting stuff happens when
you use it as an applicative functor.

applicative functor is somewhere between 

* a functor (which gives you `fmap`)

* and a monad, which gives you:
 join, >>= (bind), return

Applicative has fmap, and <*> "apply"

  (<*>) :: f (a -> b) -> f a -> f b

Like monad, there's another formulation:

  (**) :: f a -> f b -> f (a,b)

We do "do" two things in an applicative f and
then somehow combine them.

But we are restricted in how the LHS can inflence
the RHS - the RHS can't see the value that's come
out of the LHS, but the values get stuck together
at the end (using function composition in the
first case or (,) in the second case.

so back to haxl.

When you're a client of haxl, you can execute a
query against some data source.

That query might take a long time because of
eg network/database latency.

monadic style:

report n a = putStrLn $ "Your name is " ++ name ++ " and your age is " ++ show age

do
  name <- getName - 500ms
  age <- getAge person -- 500ms
  report name age

total run time 1 second.

But we could have run getName and getAge in parallel - we didn't
need to know the value of "name" in order to run
getAge person.

but the monadic interface means we have to do that - we have
to pass on the value of "name" even though on visual
inspection it doesn't matter until much later.

but this is what applicatives provide!

rather than

  getname >>= \name -> getAge >>= \age -> report name age

we could instead write something like:

 do
  (name,age) <- (,) <$> getName <*> getAge
  report name age

so we've got a monadic step still, but one of the
actions is both queries at the same time.

In ghc 8, there's applicative-do, which means that
do notation gets desugared into applicative where
possible - the results should evaluate to be the
same (as long as the applicative and monad instances
work together properly)

There are also things that can't be monads, that can
be applicatives.

For example, ZipList.


</pre>
</div>

<div class="slide">
<h1>Day 8: LogicT</h1>
<h2>more interesting stuff with evaluating lists</h2>
<p>
"A library for adding backtracking computations to any
Haskell monad" - <a href="http://okmij.org/ftp/Computation/LogicT.pdf">LogicT.pdf</a>

</p>

<pre>
Let's do a simple search:
let's try to find a number bigger than 100.

assemble all the integers: the postives, zero and
the negatives, using (++), into a single list.

the_numbers = [1..] ++ [0] ++ map (* (-1)) [1..]

We'll take the first solution returned by this
do-block:

head $ do
  n <- the_numbers
  guard (n > 100)
  return n

101

Now let's find a number less than 10:

head $ do
  n <- the_numbers
  guard (n < 10)
  return n

1

And now let's fine a number less than 0:

Straightforward, right?

head $ do
  n <- the_numbers
  guard (n < 0)
  return n

[... infinite wait ... infinite cpu ...]

What's gone wrong?

the_numbers = [1..] ++ [0] ++ map (* (-1)) [1..]

before we consider 0 and the negatives, we need to consider all
of the positives. all of them. only when we've exhausted [1..] will
we move onto evaluating the RHS terms. which is never.

whoops.


import Control.Monad.Logic

*Main Lib Control.Monad.Logic> return 5 :: [Integer]
[5]

*Main Lib Control.Monad.Logic> return 5 :: Logic Integer

<interactive>:8:1: error:
    • No instance for (Show (Logic Integer))

but we can "observe" one result:

> observe (return 5 :: Logic Integer)
5

observe acts like "head"

(return 5 :: [Integer]) `mplus` return 6
[5,6]

observe $ (return 5 :: Logic Integer) `mplus` return 6
5

observeAll $ (return 5 :: Logic Integer) `mplus` return 6
[5,6]

So this is behaving quite like a list.

Let's try out our original problem using Logic:

fromList (x:xs) = return x `mplus` fromList xs ; fromList [] = mzero

zero = return 0
positives = fromList [1..]
negatives = fmap (* (-1)) positives
the_numbers = positives `mplus` zero `mplus` negatives

This hangs...
but we have a new primitive available, interleave, which is
a bit like monadplus, but "fairer":

*Main Lib Control.Monad.Logic> the_numbers = positives `interleave` zero `interleave` negatives
*Main Lib Control.Monad.Logic> observe $ do { n <- the_numbers ; guard (n <= 0) ; return n }
-1

*Main Lib Control.Monad.Logic> take 10 $ observeAll the_numbers
[1,-1,0,-2,2,-3,3,-4,4,-5]

interleave could have been implemented as a different ++ style
operator on lists, so why do we need LogicT?


LogicT provides other stuff...
it's a transformer over arbitrary monads. (I think it's hard to do backtracking fairly over arbitrary monads?)

What does it mean to `mplus` two IO actions, for example?

Can phrase in terms of (pure) lists quite easily.

 * ifte - soft cut:

  ifte t th el  - if t succeeds at least once,  t >>= th
                  if t never succeeds, el
  (so el is our "else" / "error handling" / explain why we
    failed here...)

 * once - pruning
   once a   - selects a single solution from a - it never backtracks
     to select any others.
    - for example, when looking for a counter example, there might
       be many counter examples, but we really only care about finding
       any one of them, rather than enumerating all of them.
    but we can do this within our backtracking computation.
    (rather than external to it, which is where head/observe live

these operators are able to do things that list doesn't: they
can observe what's happening to the non-deterministic 
evaluation in a way that something living in [] cannot.
  - observations on the computation as a whole live outside like
  head.

</pre>

</div>

<div class="slide">
<h1>Day 9: Free</h1>
<h2>Free monads</h2>
back reference to Set (maybe set should be right before this and
smooth transition in?) - capture the structure of the computation
in a data structure - show full data type for Data.Monad.Set
and separately have a "run" function that runs that particular
set. and it's at the run stage that we get our type errors, not
at our construction stage. potentially we could have a different
run function!

Free monad usually based around an existing Functor, but you
can move the Functor implementation into an interpreter too,
using a free functor.

other free structure: Free monoid - is a list! can "interpret"
a list into anything that you can write a monoid instance for
</div>

<div class="slide">
<h1>Day 10:  Eff</h1>
<h2>modular interpreters and extensible effects</h2>
<pre>
* alternative to monad transformers
* compose interpreters
* difference in what can be expressed
* not so strictly layered
* I've used two implementations, based on different free monad
implementations.
</pre>
</div>

<div class="slide">
<h1>Day 11: Key</h1>
<h2>safe dynamic typing</h2>



http://www.cse.chalmers.se/~atze/papers/keymonad.pdf
also see:
https://www.seas.upenn.edu/~sweirich/papers/wadlerfest2016.pdf
for similar stuff

</div>

<div class="slide">
<h1>Day 12: Cont</h1>
<h2>continuations</h2>

<pre>
Continuations represent the rest of the
program to be run.

But wait, we've seen this somewhere before...

Right back at the start.

A monad gives us expressions that look like this:

 action >>= rest_of_program

we can do an action, and then we pass in the rest
of the program to be run, and the monad implementation
makes the rest of the program happen.
(perhaps several times or never, like in a list - it
doesn't matter - it's available to the monad
implementation to do what it cares to)

Cont makes "the rest of the program" available inside
your monadic code, with a single action:


callCC :: ((a -> Cont r b) -> Cont r a) -> Cont r a

Cont r a is a computation that will at the very end of the
program return a value of type r, but this particular piece
of computation will return a value of type a.

Run it with runCont (or runContT in this case)

callCC action  means "don't run the rest of the program.
Run action instead. (This isn't a function call - when
action exits, we don't return to where callCC was invoked).

BUT! action gets passed the rest of the program as a parameter.

and that parameter is itself a monadic action we can call which
will abandon whatever program is running and go back and
carry on as if we'd just returned from the callCC.

Sound confusing? It is. It's like the GOTO of functional programming...

We can do things like "early return" - like the return statement
of C/Java - but we can return from deep inside. so that bit
is quite like throwing an exception rather than returning.

or we could store the continuation in a table for use later on
-- to implement co-routines or a co-operative multitasking
scheduler. or for use as a callback: go stop what i'm doing now
and "return" (via the continuation) to carry on when you have
whatever the callback is for.

or look at funcD - we don't even have to run the rest of the
program. we can just ignore it and go run some arbitrary
code, and when that arbitrary code ends, that's the end of
runContT - we never get back to contMain.

very powerful. very confusing.

i've used it for a DNS diagnostic program which was non-deterministic
over DNS caches and servers 
- DNS caching looks weird so a regular list-style
non-determinism wasn't good enough.
</pre>

</div>

<div class="slide">
<p>-fin-</p>

<p><a href="https://www.meetup.com/London-Haskell/events/235629296/">meetup.com event</a></p>


</div>


<div class="slide">
<h1>example of haskell code markup</h1>
<pre><code class="haskell">want     [ jsdir &lt;/> "all.css"
         , jsdir &lt;/> "all.css.gz"
         , jsdir &lt;/> "all.min.js"
         , jsdir &lt;/> "all.min.js.gz"
         ]

"//*.min.js" %> minify
"//*.gz" %> compress
-- NO DEPENDENCIES WRITTEN HERE!

(jsdir &lt;/> "all.js") %> combineJS jsdir
(jsdir &lt;/> "all.css") %> combineCSS jsdir 
-- OR HERE!
</code></pre></div>

</html>
